compare80 <- compare(fit80$fita, fit80$fitb, fit80$fitc, fit80$fite)
n = 100
set.seed(1234)
Y <- gen_sample_pois(n)
SimData <- data.frame( ID = rep(c(1:n), each = m), Y_long = c(t(Y)), Bt_thin_long = kronecker(rep(1, n), Bt_thin))
fit100 <- fitmodels(SimData, Y, Bt, beta_init, n, Maxniter, err = 0.0001)
compare100 <- compare(fit100$fita, fit100$fitb, fit100$fitc, fit100$fite)
biastable <- rbind(compare60$bias, compare80$bias, compare100$bias)
efftable <- rbind(compare60$eff, compare80$eff, compare100$eff)
colnames(biastable) <- c("a", "b", "c", "e")
colnames(efftable) <- c("a", "b", "c", "e")
rownames(biastable) <- c("n = 60", "n = 80", "n = 100")
rownames(efftable) <- c("n = 60", "n = 80", "n = 100")
print(round(biastable, 2))
print(round(efftable, 2))
t = seq(0.02, 1.0, by = 0.15)
m = length(t)
Sigma = 0.9^ (abs(rep(1, m) %*% t(c(1:m))  - c(1:m) %*% t(rep(1, m))))
mu_t = 2*sin(4*t)
Bt <- cbind(1, t, t^2, t^3, t^4)
Bt_thin <- cbind(t, t^2, t^3, t^4)
n = 100
set.seed(1234)
Y <- gen_sample_pois(n)
SimData <- data.frame( ID = rep(c(1:n), each = m), Y_long = c(t(Y)), Bt_thin_long = kronecker(rep(1, n), Bt_thin))
fit100 <- fitmodels(SimData, Y, Bt, beta_init, n, Maxniter, err = 0.0001)
compare100 <- compare(fit100$fita, fit100$fitb, fit100$fitc, fit100$fite)
compare100
t = seq(0.02, 1.0, by = 0.5)
m = length(t)
Sigma = 0.9^ (abs(rep(1, m) %*% t(c(1:m))  - c(1:m) %*% t(rep(1, m))))
mu_t = 2*sin(4*t)
Bt <- cbind(1, t, t^2, t^3, t^4)
Bt_thin <- cbind(t, t^2, t^3, t^4)
n = 100
set.seed(1234)
Y <- gen_sample_pois(n)
SimData <- data.frame( ID = rep(c(1:n), each = m), Y_long = c(t(Y)), Bt_thin_long = kronecker(rep(1, n), Bt_thin))
fit100 <- fitmodels(SimData, Y, Bt, beta_init, n, Maxniter, err = 0.0001)
t = seq(0.2, 1.0, by = 0.05)
m = length(t)
Gamma = diag(m)
for(i in 2:m){
Gamma[i, (i - 1)] = -0.5
}
invSigma <- t(Gamma) %*% Gamma / 3
Sigma <- solve(invSigma)
beta_true <- c(1:5)
Bt <- cbind(1, t, t^2, t^3, t^4)
Bt_thin <- cbind(t, t^2, t^3, t^4)
mu_t <- Bt%*%beta_true
n = 100
set.seed(1234)
Y <- mvrnorm(n, mu_t, Sigma)
SimData <- data.frame( ID = rep(c(1:n), each = m), Y_long = c(t(Y)), Bt_thin_long = kronecker(rep(1, n), Bt_thin))
fit100 <- fitmodels(SimData, Y, Bt, beta_init, n, Maxniter, err = 0.0001)
fit100 <- fitmodels(SimData, Y, Bt, beta_init, n, Maxniter, err = 0.0001)
compare100 <- compare(fit100$fita, fit100$fitb, fit100$fitc, fit100$fite)
compare100
rnorm(5)
n <- 5
set.seed(1234)
coords <- cbind(runif(n), runif(n))
coords
Cov <- exp(-coords)
Cov
library(field)
library(fields)
Cov <- exp(-dist(coords))
Cov
Cov <- as.matrix(exp(-dist(coords)))
Cov
dist(coords)
Cov <- exp(-as.matrix(dist(coords)))
Cov
chol(Cov)
rm(list = ls())
set.seed(1)
n=20000
s=cbind(sort(runif(n,0,1)),runif(n,0,1))
phi=1
m=6
Dimgen = function(i,imvec,s)	dist(s[c(i,imvec[[i-1]]),])
rm(list = ls())
library(fields)
Dimgen = function(i,imvec,s)	dist(s[c(i,imvec[[i-1]]),])
nngp_precision <- function(s, m, phi){
pty <- Sys.time()
n = nrow(s)
m = min(m, n-1)
#imvec <- sapply(2:n, myknn, s, m)
#Dimvec <- sapply(2:n, Dimgen, imvec, s)
colind = c(1:n, unlist(imvec))
mi=c(1:(m - 1), rep(m, n - m))
rowind = c(1:n,unlist(sapply(2:n, function(i,mi) rep(i,mi[i-1]), mi)))
wimvec=sapply(2:n, function(i,Dimvec,par) {D = exp(-par*as.matrix(Dimvec[[i-1]]));as.vector(solve(D[-1,-1])%*%D[1,-1])},Dimvec,phi)
fimvec=sapply(2:n, function(i,Dimvec,wimvec,par) {D=as.matrix(Dimvec[[i-1]]);1-exp(-par*D[1,-1])%*%wimvec[[i-1]]}, Dimvec,wimvec,phi)
V=sparseMatrix(i = rowind, j = colind, x = c(rep(1, n), -unlist(wimvec)),dims=c(n,n))
F=sparseMatrix(i = 1:n, j = 1:n, x = c(1, 1 / fimvec), dims = c(n,n))
nngpprec=t(V)%*%F%*%V
t <-  Sys.time() - pty; cat(t)
}
set.seed(1)
n=5
s=cbind(sort(runif(n,0,1)),runif(n,0,1))
phi=1
m=6
Cov <- exp(-as.matrix(dist(coords)))
pty <- Sys.time(); exp_GP_prec=solve(exp(-phi*as.matrix(dist(s)))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_GP_prec=chol2inv(chol(exp(-phi*as.matrix(dist(s))))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_NNGP_prec=nngp_precision(s,m,phi);t <-  Sys.time() - pty; t
set.seed(1)
n=5
s=cbind(sort(runif(n,0,1)),runif(n,0,1))
phi=1
m=6
pty <- Sys.time(); exp_GP_prec=solve(exp(-phi*as.matrix(dist(s)))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_GP_prec=chol2inv(chol(exp(-phi*as.matrix(dist(s))))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_NNGP_prec=nngp_precision(s,m,phi)
rm(list = ls())
library(fields)
Dimgen = function(i,imvec,s)	dist(s[c(i,imvec[[i-1]]),])
nngp_precision <- function(s, m, phi){
pty <- Sys.time()
n = nrow(s)
m = min(m, n-1)
#imvec <- sapply(2:n, myknn, s, m)
#Dimvec <- sapply(2:n, Dimgen, imvec, s)
colind = c(1:n, unlist(imvec))
mi=c(1:(m - 1), rep(m, n - m))
rowind = c(1:n,unlist(sapply(2:n, function(i,mi) rep(i,mi[i-1]), mi)))
wimvec=sapply(2:n, function(i,Dimvec,par) {D = exp(-par*as.matrix(Dimvec[[i-1]]));as.vector(solve(D[-1,-1])%*%D[1,-1])},Dimvec,phi)
fimvec=sapply(2:n, function(i,Dimvec,wimvec,par) {D=as.matrix(Dimvec[[i-1]]);1-exp(-par*D[1,-1])%*%wimvec[[i-1]]}, Dimvec,wimvec,phi)
V=sparseMatrix(i = rowind, j = colind, x = c(rep(1, n), -unlist(wimvec)),dims=c(n,n))
F=sparseMatrix(i = 1:n, j = 1:n, x = c(1, 1 / fimvec), dims = c(n,n))
nngpprec=t(V)%*%F%*%V
t <-  Sys.time() - pty; cat(t)
}
set.seed(1)
n=5
s=cbind(sort(runif(n,0,1)),runif(n,0,1))
phi=1
m=6
pty <- Sys.time(); exp_GP_prec=solve(exp(-phi*as.matrix(dist(s)))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_GP_prec=chol2inv(chol(exp(-phi*as.matrix(dist(s))))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_NNGP_prec=nngp_precision(s,m,phi)
imvec <- sapply(2:n, myknn, s, m)
Dimgen = function(i,imvec,s)	dist(s[c(i,imvec[[i-1]]),])
nngp_precision <- function(s, m, phi){
pty <- Sys.time()
n = nrow(s)
m = min(m, n-1)
imvec <- sapply(2:n, myknn, s, m)
Dimvec <- sapply(2:n, Dimgen, imvec, s)
colind = c(1:n, unlist(imvec))
mi=c(1:(m - 1), rep(m, n - m))
rowind = c(1:n,unlist(sapply(2:n, function(i,mi) rep(i,mi[i-1]), mi)))
wimvec=sapply(2:n, function(i,Dimvec,par) {D = exp(-par*as.matrix(Dimvec[[i-1]]));as.vector(solve(D[-1,-1])%*%D[1,-1])},Dimvec,phi)
fimvec=sapply(2:n, function(i,Dimvec,wimvec,par) {D=as.matrix(Dimvec[[i-1]]);1-exp(-par*D[1,-1])%*%wimvec[[i-1]]}, Dimvec,wimvec,phi)
V=sparseMatrix(i = rowind, j = colind, x = c(rep(1, n), -unlist(wimvec)),dims=c(n,n))
F=sparseMatrix(i = 1:n, j = 1:n, x = c(1, 1 / fimvec), dims = c(n,n))
nngpprec=t(V)%*%F%*%V
t <-  Sys.time() - pty; cat(t)
}
set.seed(1)
n=5
s=cbind(sort(runif(n,0,1)),runif(n,0,1))
phi=1
m=6
pty <- Sys.time(); exp_GP_prec=solve(exp(-phi*as.matrix(dist(s)))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_GP_prec=chol2inv(chol(exp(-phi*as.matrix(dist(s))))) ;t <-  Sys.time() - pty; t
pty <- Sys.time(); exp_NNGP_prec=nngp_precision(s,m,phi)
library('Matrix')
library("fields")
library(rstan)
model_code <-
"
functions {
matrix getADstan(matrix neardist, matrix neardistM,
matrix nearind, int N, int M, real phi) {
int dim;
int h;
matrix[N, M + 1] AD;
for (i in 2:N) {
matrix[ i < (M + 1)? (i - 1) : M, i < (M + 1)? (i - 1): M] temp_neardistM;
matrix[ i < (M + 1)? (i - 1) : M, i < (M + 1)? (i - 1): M] L;
vector[ i < (M + 1)? (i - 1) : M] u;
vector[ i < (M + 1)? (i - 1) : M] v;
row_vector[i < (M + 1)? (i - 1) : M] v2;
dim = (i < (M + 1))? (i-1) : M;
//print(i);
// get exp(-phi * neardistM)
if(dim == 1){temp_neardistM[1, 1] = 1;}
else{
h = 0;
for (j in 1:(dim - 1)){
for (k in (j + 1):dim){
h = h + 1;
temp_neardistM[j, k] = exp(- phi * neardistM[(i - 1), h]);
temp_neardistM[k, j] = temp_neardistM[j, k];
}
}
for(j in 1:dim){
temp_neardistM[j, j] = 1;
}
}
L = cholesky_decompose(temp_neardistM);
for (j in 1: dim){
u[j] = exp(- phi * neardist[(i - 1), j]);
}
//vector[dim] v;
v = mdivide_left_tri_low(L, u);
AD[i, (M+1)] = (1.0 - (v' * v));
v2 = mdivide_right_tri_low(v', L);
for(j in 1:dim){
AD[i, j] = v2[j];
}
}
AD[1, (M+1)] = 1;
return AD;}
}
model {}
"
expose_stan_functions(stanc(model_code = model_code))
library(rstan)
stan_version()
citation()
citation("rstan")
citation()
citation("RcppEigen")
citation("gstat")
print(gstat,
bibtex=TRUE)
print(<Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat
package. Computers & Geosciences, 30: 683-691.
Benedikt Gräler, Edzer Pebesma and Gerard Heuvelink, 2016.
Spatio-Temporal Interpolation using gstat.  The R Journal 8(1),
204-218>,
bibtex=TRUE)
print(<Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat
package. Computers & Geosciences, 30: 683-691.
Benedikt Gräler, Edzer Pebesma and Gerard Heuvelink, 2016.
Spatio-Temporal Interpolation using gstat.  The R Journal 8(1),
204-218>,
bibtex=TRUE)
1/0.9257499
sqrt(1.51003603)
sqrt(0.04426536)
2* 0.210
2* 1.22883
library()
library()
library(geoR)
library(geoR)
rm(list=ls())
library(spNNGP)
library(MBA)
library(fields)
rmvn <- function(n, mu=0, V = matrix(1)){
p <- length(mu)
if(any(is.na(match(dim(V),p))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}
data(CHM)
CHM <- CHM[CHM[,3]>0,]
sigma.sq.IG <- c(2, 15)
cov.model <- "exponential"
set.seed(1)
mod <- sample(1:nrow(CHM), 500000)
CHM.mod <- CHM[mod,]
theta.alpha <- c(0.07, 0.13)
names(theta.alpha) <- c("phi", "alpha")
m.c.big <- spConjNNGP(CHM.mod[,3] ~ 1, coords=CHM.mod[,1:2], n.neighbors = 10,
theta.alpha = theta.alpha,
n.omp.threads = 2,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
rm(list=ls())
library(spNNGP)
data(CHM)
CHM <- CHM[CHM[,3]>0,]
set.seed(1)
mod <- sample(1:nrow(CHM), 500000)
CHM.mod <- CHM[mod,]
sigma.sq.IG <- c(2, 15)
cov.model <- "exponential"
theta.alpha <- c(0.07, 0.13)
names(theta.alpha) <- c("phi", "alpha")
t <- proc.time()
m.c.big <- spConjNNGP(CHM.mod[,3] ~ 1, coords=CHM.mod[,1:2], n.neighbors = 10,
theta.alpha = theta.alpha,
n.omp.threads = 2,
sigma.sq.IG = sigma.sq.IG, cov.model = cov.model)
proc.time() - t
100 - 2*(100 - 98.61)
rm(list=ls())
2*(100 - 98.61)
2*(100 - 99.38)
11/4
sample <- c(7,6,6,3,2,5)
mean(sample)
var(sample)
m <- mean(sample)
sum((sample - m)^2)/5
11+2+8+5-100
19+20+10
1.1 109
1.1*109
21^2 - 4*108
0.1^(0.01)
2+6+9+4
2+4
8+1+7+2+1+4+9+9+4+1
100-8-8-3-4-9-9-5
100-8-2-5-2-9-6-2
2+7+2
2+7+13+8
2+2+4+3
8+6
1+12+4
8+4+8+9
1+5
7+1+9+4
13+8
1+7+4+1
(199*(4.798^2) + 99*4.296^2)/(300-2)
67.245 - 62.820
1.96*sqrt(21.50418)*sqrt(1/200 + 1/100)
4.425 + 1.113174
4.425 - 1.113174
(199*2.87^2 + 99*2.11^2)/298
5.51 - 3.58
1.96*sqrt(6.979534)*sqrt(1/200 + 1/100)
1.93 + 0.6341835
1.93 - 0.6341835
0.584*2.79/5.079
4*52 -12*2
4*52 -12^2
52/64
52/4
64/4
-20+25
25+18
36+7
25-18
36-7
19 - 30
8*30*5/7
8*30*5/7 *0.25
8*30*5/7 *0.2
4*8
knitr::opts_chunk$set(echo = TRUE, tidy = F, warning=FALSE, comment=NA)
setwd("/Users/luzhang/Documents/github/NNGP_STAN")
rm(list = ls())
rmvn <- function(N, mu = 0, V = matrix(1)){
P <- length(mu)
if(any(is.na(match(dim(V), P))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(N * P), ncol = P) %*% D + rep(mu, rep(N, P)))
}
set.seed(1234)
N <- 500
coords <- cbind(runif(N), runif(N))
X <- as.matrix(cbind(1, rnorm(N)))
B <- as.matrix(c(1, 5))
sigma.sq <- 2
tau.sq <- 0.1
phi <- 3 / 0.5
D <- as.matrix(dist(coords))
R <- exp(-phi*D)
w <- rmvn(1, rep(0, N), sigma.sq*R)
Y <- rnorm(N, X %*% B + w, sqrt(tau.sq))
library(spNNGP)       # Build neighbor index
theta.alpha <- c(5, 0.5)
names(theta.alpha) <- c("phi", "alpha")
m.c <- spConjNNGP(Y ~ X[, -1], coords = coords, n.neighbors = M,
theta.alpha = theta.alpha,
k.fold = 2,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = c(2, 1), cov.model = "exponential")
M = 6  # Number of Nearest Neighbors
theta.alpha <- c(5, 0.5)
names(theta.alpha) <- c("phi", "alpha")
m.c <- spConjNNGP(Y ~ X[, -1], coords = coords, n.neighbors = M,
theta.alpha = theta.alpha,
k.fold = 2,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = c(2, 1), cov.model = "exponential")
list("phi" = 5, "alpha" = 0.5)
c("phi" = 5, "alpha" = 0.5)
m.c <- spConjNNGP(Y ~ X[, -1], coords = coords, n.neighbors = M,
theta.alpha = c("phi" = 5, "alpha" = 0.5),
k.fold = 2,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = c(2, 1), cov.model = "exponential")
m.c <- spConjNNGP(Y ~ X[, -1], coords = coords, n.neighbors = M,
theta.alpha = c("phi" = 5, "alpha" = 0.5),
k.fold = 1,
n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = c(2, 1), cov.model = "exponential")
library(spNNGP)       # Build neighbor index
M = 6                 # Number of Nearest Neighbors
m.c <- spConjNNGP(Y ~ X[, -1], coords = coords, n.neighbors = M,
theta.alpha = c("phi" = 5, "alpha" = 0.5),
k.fold = 1, n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = c(2, 1), cov.model = "exponential")
source("NNmatrix.R")  # Build matrix including nearest neighbor information
NN.matrix <- NNMatrix(N, m.c$coords.ord, m.c$n.indx[-1])
str(NN.matrix)
Check_Neighbors(m.c$coords.ord, NN = M, NN.matrix, ind = 200)
m.c <- spConjNNGP(Y ~ X[, -1], coords = coords, n.neighbors = M,
theta.alpha = c("phi" = 5, "alpha" = 0.5),
k.fold = 5, n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = c(2, 1), cov.model = "exponential")
source("NNmatrix.R")  # Build matrix including nearest neighbor information
NN.matrix <- NNMatrix(N, m.c$coords.ord, m.c$n.indx[-1])
str(NN.matrix)
Check_Neighbors(m.c$coords.ord, NN = M, NN.matrix, ind = 200)
?spConjNNGP
setwd("/Users/luzhang/Documents/github/NNGP_STAN")
rm(list = ls())
library(rstan)
library(shinystan)
library(spNNGP)       # Build neighbor index
source("NNmatrix.R")  # Build matrix including nearest neighbor information
#------------------------- generate simulation data ---------------------------#
rmvn <- function(N, mu = 0, V = matrix(1)){
P <- length(mu)
if(any(is.na(match(dim(V), P))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(N * P), ncol = P) %*% D + rep(mu, rep(N, P)))
}
set.seed(1234)
N <- 500
coords <- cbind(runif(N), runif(N))
X <- as.matrix(cbind(1, rnorm(N)))
B <- as.matrix(c(1, 5))
sigma.sq <- 2
tau.sq <- 0.1
phi <- 3 / 0.5
D <- as.matrix(dist(coords))
R <- exp(- phi * D)
w <- rmvn(1, rep(0, N), sigma.sq*R)
Y <- rnorm(N, X %*% B + w, sqrt(tau.sq))
#----------------------- Empirival Variogram (for fun) ------------------------#
library(geoR)     # empirical variogram
library(spBayes)  # function iDist
par(mfrow = c(1, 1))
lm.obj <- lm(Y ~ X[, -1])
d.max <- max(iDist(coords))
v.resid <- variog(coords=coords, data=resid(lm.obj),
uvec=(seq(0, 0.6 * d.max, length = 20)))
vario.fit <- variofit(v.resid, cov.model="exponential")
plot(v.resid, main = 'Empirical Variogram', cex = 0.2, ylim = c(0, 3.5))
lines(vario.fit, col='red')
#-------------- Build neighbor index on sorted x by "spConjNNGP" --------------#
M = 6                 # Number of Nearest Neighbors
m.c <- spConjNNGP(Y ~ X[, -1], coords = coords, n.neighbors = M,
theta.alpha = c("phi" = 5, "alpha" = 0.5),
k.fold = 1, n.omp.threads = 2, return.neighbors = T,
sigma.sq.IG = c(2, 1), cov.model = "exponential")
NN.matrix <- NNMatrix(N, m.c$coords.ord, m.c$n.indx[-1])
par(mfrow=c(1,1))
Check_Neighbors(m.c$coords.ord, NN = M, NN.matrix, ind = 200)
0.2*60
setwd("/Users/luzhang/Documents/github/NNGP_STAN")
rm(list = ls())
library(rstan)
library(shinystan)
library(spNNGP)       # Build neighbor index
setwd("/Users/luzhang/Documents/github/NNGP_STAN")
rm(list = ls())
library(rstan)
library(shinystan)
library(spNNGP)       # Build neighbor index
source("NNmatrix.R")  # Build matrix including nearest neighbor information
rmvn <- function(N, mu = 0, V = matrix(1)){
P <- length(mu)
if(any(is.na(match(dim(V), P))))
stop("Dimension problem!")
D <- chol(V)
t(matrix(rnorm(N * P), ncol = P) %*% D + rep(mu, rep(N, P)))
}
set.seed(1234)
N <- 500
coords <- cbind(runif(N), runif(N))
X <- as.matrix(cbind(1, rnorm(N)))
B <- as.matrix(c(1, 5))
sigma.sq <- 2
tau.sq <- 0.1
phi <- 3 / 0.5
D <- as.matrix(dist(coords))
R <- exp(- phi * D)
w <- rmvn(1, rep(0, N), sigma.sq*R)
Y <- rnorm(N, X %*% B + w, sqrt(tau.sq))
library(geoR)     # empirical variogram
?mvrnorm
set.seed(1234)
N <- 500
coords <- cbind(runif(N), runif(N))
X <- as.matrix(cbind(1, rnorm(N)))
B <- as.matrix(c(1, 5))
sigma.sq <- 2
tau.sq <- 0.1
phi <- 3 / 0.5
D <- as.matrix(dist(coords))
R <- exp(- phi * D)
w <- mvrnorm(1,rep(0, N), sigma.sq*R)
w <- rmvn(1, rep(0, N), sigma.sq*R)
